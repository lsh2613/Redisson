## 01. 프로젝트 설명
- 동시성 이슈 해결을 위해  낙관적 락, 비관적 락, 분산락을 적용한 프로젝트
- Redisson을 활용하여 분산락을 구현하였다.
- 분산락 성능 개선을 위해 함수형 프로그래밍을 통하여 락이 필요한 부분만 락을 적용하였다.

## 02. 기능
- 낙관적 락을 통한 동시성 이슈 해결
- 비관적 락을 통한 동시성 이슈 해결
- 분산락을 통한 동시성 이슈 해결
- 함수형 프로그래밍을 통한 분산락 성능 개선

## 03. 사용 기술
- `Spring Boot 3.2`, `Spring Data JPA`
- `Redis`, `Redisson`
- `MySQL`
- `Docker`, `Docker Compose`

## 04. 관련 이슈
- [낙관적 락 vs 비관적 락 vs 분산락](https://lsh2613.tistory.com/270)
- [함수형 프로그래밍을 적용한 분산락 성능 개선](https://lsh2613.tistory.com/271)

## 05. 테스트 결과
**[ 테스트 설명 ]**
- Ticket의 quantity(수량)은 1000개 할당
- 100개의 요청을 32개의 스레드로 처리
- 하나의 요청은 생성한 티켓에서 수량을 1개 감소하도록 적용

**[ 동시성 이슈 해결 성공 ]**
![image](https://github.com/user-attachments/assets/4f8b207b-d61e-403a-bfb4-354df909a5b8)
![image](https://github.com/user-attachments/assets/e3ced8b8-f560-43e9-accf-6d4ad09cf4a5)

**[ 분산락 성능 개선 ]**
- 성능 개선 테스트를 위해 기존(함수형 프로그래밍 적용 전)과 성능 개선(함수형 프로그래밍 적용 후) 로직에 `sleep(500)`을 적용
- 따라서, 이 요청에는 락이 불필요한 영역(sleep(500):0.5초)과 락이 필요한 영역(티켓 개수 감수)이 포함되어있다

**[ 성능 개선 전 ]**
![image](https://github.com/user-attachments/assets/88392ced-3212-4ee7-94e4-75fbc8b3ff3c)

**[ 성능 개선 후 ]**
![image](https://github.com/user-attachments/assets/702d7d4c-9ffd-4b63-9ae7-2fa7909d07ad)

**[ 결과 ]**

개선 전 코드는 52.8초 vs 개선 후 코드는 2.8초라는 결과에 집중하자

개선된 코드는 락이 필요한 영역만 락을 할당해줬기 때문에 약 100개의 요청마다 0.5초를 아꼈다.

즉, 개선 전 후의 차이인 50초는 100 * 0.5 = 50의 결과이다.


이를 통해 락이 필요한 영역에만 락을 할당해주었기 때문에 락이 불필요한 영역을 로직은 락을 기다리지 않고 먼저 실행될 수 있었고 50초라는 시간의 이점을 얻을 수 있었다.
